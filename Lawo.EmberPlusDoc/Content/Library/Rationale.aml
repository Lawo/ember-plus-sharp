<?xml version="1.0" encoding="utf-8"?>
<topic id="c17ed1f5-6b3d-40f5-af29-b1d031ae24cd" revisionNumber="1">
  <developerConceptualDocument
    xmlns="http://ddue.schemas.microsoft.com/authoring/2003/5" xmlns:xlink="http://www.w3.org/1999/xlink">
    <introduction>
      <autoOutline/>
    </introduction>
    <section address="HighEffort">
      <title>Other Libraries Require a High Effort to Implement a New Consumer</title>
      <content>
        <para>
          Currently, all other publicly available <application>Ember+</application> libraries only offer APIs for the
          the serialization and deserialization of <application>Glow DTD</application> objects. Every company that
          decides to have one of their products act as a fully functional <application>Ember+</application> consumer
          therefore needs to repeat the following steps:
        </para>
        <list class="bullet">
          <listItem>
            <para>
              Newly implement a data structure or extend an existing data structure so that it offers the following
              capabilities:
            </para>
            <list class="bullet">
              <listItem><para>Apply a change received from the provider.</para></listItem>
              <listItem><para>Apply a locally made change.</para></listItem>
              <listItem><para>Enable client code to be notified about changes.</para></listItem>
              <listItem>
                <para>
                  Defer the application of provider changes until pending local changes have been sent to the provider.
                </para>
              </listItem>
            </list>
          </listItem>
          <listItem>
            <para>Recursively query the provider for the parts of the tree the consumer is interested in.</para>
          </listItem>
          <listItem>
            <para>
              Detect and handle mismatches between the tree structure expected by the consumer and the tree structure
              received from the provider.
            </para>
          </listItem>
          <listItem>
            <para>Apply change messages received from the provider to the local data structure.</para>
          </listItem>
          <listItem>
            <para>Serialize local changes into appropriate messages and send them to the provider.</para>
          </listItem>
          <listItem><para>Implement the keep alive mechanism.</para></listItem>
        </list>
        <para>
          The <link xlink:href="915a270d-2a20-432f-9531-ce6aa3260566"/> on the other hand implements all of the above in
          easily reusable components such that a consumer can be implemented in less than an hour. With any other
          publicly available library this currently takes at least days if not weeks.
        </para>
      </content>
    </section>
    <section address="EmberLibDotNetUnsuitable">
      <title>EmberLib.net is Unsuitable as a Foundation</title>
      <content>
        <para>
          Some of the types in the <codeEntityReference>N:Lawo.EmberPlus.S101</codeEntityReference> and
          <codeEntityReference>N:Lawo.EmberPlus.Ember</codeEntityReference> namespaces duplicate functionality already
          offered by <application>EmberLib.net</application> in the
          <externalLink>
            <linkText>ember-plus</linkText>
            <linkUri>https://github.com/Lawo/ember-plus</linkUri>
          </externalLink>
          repository. For the reasons documented below, it has been decided to reimplement all functionality from scratch.
        </para>
        <list class="bullet">
          <listItem>
            <para>
              There are no unit tests for <application>EmberLib.net</application>. It seems obvious that for just about
              any serious application, reliable communication over <application>Ember+</application> is of the utmost
              importance. It is therefore dangerous to use a library that cannot be easily tested whenever a new library
              release is published. By comparison, the <application>Ember+ Sharp Library</application> is currently
              covered with automated tests to ~95% statement coverage.
            </para>
          </listItem>
          <listItem>
            <para>
              In many places the API provided by <application>EmberLib.net</application>, does not seem to follow
              well-established .NET conventions, for example:
            </para>
            <list class="bullet">
              <listItem>
                <para>Error conditions are largely undocumented.</para>
              </listItem>
              <listItem>
                <para>Some error conditions are reported by callbacks instead of exceptions.</para>
              </listItem>
              <listItem>
                <para>
                  The library makes it overly difficult to operate on
                  <codeEntityReference>T:System.IO.Stream</codeEntityReference> objects. Most
                  <application>.NET</application> communication APIs however provide streams (e.g.
                  <codeEntityReference>T:System.Net.Sockets.NetworkStream</codeEntityReference> or
                  <codeEntityReference>T:System.IO.Pipes.PipeStream</codeEntityReference>).
                </para>
              </listItem>
            </list>
          </listItem>
          <listItem>
            <para>
              For applications that visualize data communicated over <application>Ember+</application>, it seems best
              when messages are processed directly on the GUI thread. With such an approach, it is absolutely crucial
              that all code involved in the processing <application>Ember+</application> traffic must offer the best
              possible performance. From a cursory glance at the <application>EmberLib.net</application> source code, it
              appears that the implementation is unnecessarily inefficient in many places. This impression is partially
              confirmed by a [performance comparison](\ref EmberLibNetVsLawoEmberPlusPerformanceComparison) of the
              <codeInline>GlowOutput</codeInline> class with the
              <codeEntityReference>T:Lawo.EmberPlus.S101.S101Writer</codeEntityReference> class. The former is ~1.9
              times slower than the latter.
            </para>
          </listItem>
        </list>
      </content>
    </section>
    <section address="UnitTests">
      <title>Unit Tests</title>
      <content>
      </content>
    </section>
    <section address="DotNetConventions">
      <title>.NET Conventions</title>
      <content>
      </content>
    </section>
    <section address="Efficiency">
      <title>Efficiency</title>
      <content>
      </content>
    </section>
    <relatedTopics/>
  </developerConceptualDocument>
</topic>
